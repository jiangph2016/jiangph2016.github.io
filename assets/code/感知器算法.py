# -*- coding: utf-8 -*-
"""感知器算法.ipynb

Automatically generated by Colaboratory.

Original file is located at
        https://colab.research.google.com/drive/1uMcSUjFe0Sz3yInk2ir5xoBnFwmlsIpp
"""

# -*- coding:utf-8
import numpy as np
a = [[0,0,0],[1,0,0],[1,0,1],[1,1,0]]
b = [[0,0,1],[0,1,1],[0,1,0],[1,1,1]]
dim=3
#数据定义

a_num = len(a)
b_num = len(b)

a_array=[]
for i in range(a_num):
    a[i].append(1)
    tmp_narry = np.array(a[i])
    print(tmp_narr)
    a_array.append(tmp_narry)

# 对属于b的样本，先增广，再乘以-1
b_array=[]
for i in range(b_num):
    b[i].append(1)
    b[i] = np.dot(b[i],-1)
    tmp_narry = np.array(b[i])
    print(tmp_narr)
    b_array.append(tmp_narry)


array = a_array+b_array

# 设定初始的w为(0,0,0,0)T
w = np.zeros(dim+1).T
# 取矫正向量为1
C = 1
# 分别为参数的序号和迭代的次数
w_num = 0
iter_num = 1
while True:
    #flag默认为false，如果本轮迭代中出现了分类错误的情况
	#则变更为True
    flag = False
    print("第%d轮迭代:"%iter_num)
    for arr in array:
        res = np.dot(arr,w)
        print(arr,"*",w,end='')
        if res<=0:
            print("="+str(res)+"<=0",end='     ')
            print("故w("+str(w_num+1)+")=w("+str(w_num)+")+",arr)
            w = w + np.dot(arr,C)
            flag=True
        else:
            print("="+str(res)+">0",end='     ')
            print("故w("+str(w_num+1)+")=w("+str(w_num)+")")
        w_num = w_num + 1
    iter_num = iter_num + 1
	#迭代次数超过999次先结束运行
    if flag==False or iter_num>999:
        break
print("w:",w)
print("d(x)="+str(w[0])+"*X1+"+str(w[1])+"*X2+"+str(w[2])+"*X3+"+str(w[3]))

