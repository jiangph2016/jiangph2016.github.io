---
layout: post
title: 【精读】实时加密勒索软件检测
category: 学术
tags: 论文
keywords: 勒索软件
---
* content
{:toc}


类型  |内容  
-- |--  
标题 |RWGuard: A Real-Time Detection System Against Cryptographic Ransomware
时间 |2019
会议 |International Symposium on Recent Advances in Intrusion Detection
引用 |Mehnaz S, Mudgerikar A, Bertino E. Rwguard: A real-time detection system against cryptographic ransomware[C]//International Symposium on Research in Attacks, Intrusions, and Defenses. Springer, Cham, 2018: 114-136.

## 文章简介

RAID 2019.文章提出了一个关于加密勒索软件的实时检测系统RWGuard，它通过部署诱饵文件、监视进程、分析用户行为等方式对加密勒索软件进行了有效的检测。最后使用14个流行的加密勒索软件对该系统进行评估，假阴性率为0，假阳性为0.1%，并且只产生了1.9%的额外开销。

## 会议介绍

International Symposium on
Research in Attacks, Intrusions and Defenses
（攻击、入侵和防御研究国际研讨会），之前的名称为International Symposium on Recent Advances in Intrusion Detection (RAID)，致力于在入侵检测领域共享信息。


## 作者介绍

Shagufta Mehnaz, Anand Mudgerikar,Elisa Bertino
Purdue University，West Lafayette, IN, USA

## 摘要

勒索软件最近成为一种流行的恶意软件，其目标广泛，从个人用户到公司用户，都是为了金钱利益。现有勒索软件检测机制无法实时提供预警，这会导致大量文件的不可逆加密，而加密后的处理技术（例如，密钥提取，文件还原）则有很多的局限性。

现有的检测机制有较高的误报率且无法确定文件更改的原始意图，即它们无法区分文件变化是由于勒索软件加密还是由于用户对文件操作（例如正常加密或压缩）造成的。为了解决这些挑战，本文介绍了一种勒索软件检测机制RWGuard，它可以通过
（1）部署诱饵技术  
（2）仔细监视正在运行的进程和文件系统中的恶意活动  
（3）通过了解用户的加密行为，可以避免标记出正常的文件更改行为  
我们对迄今为止14个最流行的勒索软件家族的样本进行了评估，实验表明RWGuard在实时检测时勒索软件时非常有效，假阴性率为0，假阳性率可以忽略不计（0.1%），同时只产生1.9%的开销。

## 介绍

勒索软件是一类最近在网络犯罪中非常流行的恶意软件。这些网络罪犯的目标是通过劫持用户的文件来获取经济利益——要么加密文件，要么锁定用户的计算机。在本文中，我们将重点放在加密勒索软件上，它向用户索要赎金，以交换解密密钥，这些密钥可用于恢复攻击者加密的文件。这样一个勒索软件对个人和组织来说是一个重大的威胁。在最近的勒索软件攻击中，**Petya**是最致命的一个，它影响了好几家制药公司、银行和至少一个机场和一家美国医院。另一个席卷全球近100个国家的大规模勒索软件是**WannaCry**。这次袭击不仅针对大型机构，也针对个人用户。尽管自2005年以来勒索软件一直是最大的威胁之一，但第一次勒索软件攻击发生在1989年，目标是医疗保健行业。拥有非常敏感和关键信息的医疗行业仍然是首要目标。
即使已经提出了很多检测恶意软件的技术，但只要少数有关于勒索软件检测的技术，且这些现有技术具有以下限制：  
（a）具有不可避险的延迟，当几个文件已经被加密时才能检测  
（b）无法区分正常的文件更改与勒索软件加密  
（c）离线检测系统无法实时检测勒索软件  
（d）仅强调加密后阶段，该阶段大多数情况下无法恢复文件或与 __安全的删除冲突__  
（e）安装后仅在有限的时间内监视应用程序的操作。


**问题和范围**:在这项工作中，我们关注成功的勒索软件最关键的需求，即使用户无法获得有价值的资源（即文件、文档），并设计一个解决方案RWGuard，通过在早期阶段检测和停止勒索软件进程来保护文件。锁定用户机器的勒索软件系列不在本文的讨论范围内。

**方法**：RWGuard使用三种监视技术：诱饵监视，过程监视和文件更改监视。 与普通恶意软件不同，勒索软件能在几分钟（或几秒钟）内破坏系统。 因此，分析进程的文件使用模式并搜索类似勒索软件的行为会导致检测延迟。 为了应对这一挑战，我们从战略上在系统中部署了许多诱饵文件。 由于在正常情况下不应读写诱饵文件，因此，每当勒索软件进程读写该诱饵文件时，我们的诱饵监视技术便会立即识别出勒索软件进程。 尽管已经有一些研究工作使用诱饵文件来检测勒索软件，但先前的工作并未在任何实际系统设计中对这些诱饵文件的有效性进行分析。据我们所知，**我们的工作首先对诱饵技术检测勒索进行了实证分析** 。进程监视器检查运行中进程的I / O请求数据包（IRPs，I/O Request Packets），例如IRP写、创建、打开。尽管某些现有方法是基于签名的并且寻找特定的I / O请求模式，但我们利用勒索软件的快速加密属性，使用许多IRP指标为每个运行过程构建基线配置文件，并利用这些基线配置文件执行过程异常检测。文件更改监视器检查对文件执行的所有更改（例如，创建、删除和写入操作），以确定异常文件更改。从我们的实验观察中，我们发现仅监视过程活动或仅监视文件更改是不足以有效地检测恶意行为，并可能产生较高的假正率和假负率（例如，我们观察到**Cryptolocker**勒索软件对文件的加密非常慢，有时会逃避过程监控）。在本文中，我们将增强这些现有技术，并将其与诱饵监控模块结合起来，以提供有效的解决方案来防范勒索软件

如果发现了某一个文件（非诱饵文件）的潜在加密行为，则接下来是确定文件是由勒索软件还是由合法用户加密的。 因此，我们还设计了一种文件分类机制，该机制根据文件的属性将加密分类为良性或恶意。为了了解用户的文件加密行为，我们用现有的加密程序（它利用加密库CryptoAPI，例如Kryptel）供用户和应用程序使用。 最后，我们的方法使用了一种机制，该机制可以放置钩子并拦截对CryptoAPI库中的函数的调用，从而监视所有良性文件的加密

**贡献**：总而言之，RWGuard的贡献如下：
1. 一种基于诱饵的勒索软件检测技术，能够实时识别运行中的勒索软件进程。
2. 一个同时使用过程和文件更改监视的勒索软件监视系统（用于检测除诱饵以外的勒索软件加密文件）  
3. 一种分类机制，通过对CryptoAPI功能放置钩子并学习用户的文件加密行为，来区分良性文件更改和勒索软件加密 
4. 我们对该系统检测14个最流行的勒索软件的效果进行了广泛的评估

## 背景

**混合密码系统**  
混合密码系统允许勒索软件使用不同的对称密钥和一个非对称密钥对不同的文件进行加密。 攻击者通过命令生成不对称的密钥对。 勒索软件代码为要加密的每个文件生成唯一的对称密钥，然后使用公钥对这些对称密钥进行加密。 这些加密的对称密钥与加密的文件一起保留。 用户需要支付赎金以获取私钥，使用私钥可以获取对称密钥，然后解密文件。

**IRPLogger**
所有由进程发送到设备驱动程序的I/O请求都打包在I/O请求包（IRPs）中。这些请求是为所有文件系统的操作生成的(例如打开、关闭、写入、读取等)，IRPLogger利用一个小的过滤器驱动程序来拦截I/O请求。IRPLogger条目的示例如下：  
`<Timestamp, PID, IRP/FastIO, Operation (READ/WRITE/OPEN/CLOSE/CREATE)>`  


**CryptoAPI**
CryptoAPI是Microsoft Windows平台特定的加密图形应用程序编程接口（API）。 这个API包含在Windows操作系统中，用于保护基于Windows的应用程序的服务。 它包括加密（CryptEncrypt）和解密（CryptDecrypt）数据，生成加密安全的伪随机数（CryptGenRandom），使用数字证书进行身份验证的功能。

**微软Detours库**
Detours库用于在与Windows兼容的处理器中检测任意Win32函数。它通过重新写入目标函数的内存代码来拦截Win32函数。Detours将未检测的目标函数（可通过蹦床调用？？？trampoline）作为子例程供检测使用。


## RWGuard Design

### 3.1 威胁模型
在我们的威胁模型中，我们考虑攻击者通过看似合法但恶意的域在受害者机器上安装加密勒索软件。我们认为操作系统是可信的。勒索软件通常加密用户创建和关心的文件，且用户帐户已经拥有访问这些文件的所有权限。然而，尽管勒索软件仅以用户级权限执行的假设似乎是合理的（与其他假设一样，勒索软件可能能够击败主机保护机制中的任何现有机制，例如反恶意软件解决方案），但此假设并不适用于所有运行过的勒索软件情况。
我们观察到这种假设的一些例外情况，一些勒索软件仅影响预定义的文件列表，如果未检测到或被终止，则获取Root访问权限，然后关闭系统并在下次启动时执行完整磁盘加密并要求支付勒索金。因此，我们也将这些勒索软件样本包含在我们的威胁模型中。此外，组织内部的攻击人员可能会获得诱饵文件的知识，并构建一个定制的勒索软件来破坏组织（例如一个逻辑炸弹，在离职后触发）。

### 3.2 概览
图1显示了RWGuard的设计概述。首先，需要由I/O调度程序调度由任何用户空间进程生成的对文件系统的任何I/O请求。我们利用IRPLogger来获取这些系统范围的文件系统访问请求，并使用IRPParser解析这些请求，
RWGuard包括五个模块：
（1）诱饵监视（DMon）模块  
（2）进程监视（PMon）模块  
（3）文件更改监视（FCMon）模块  
（4）文件分类（FCls）模块  
（5）CryptoAPI函数钩子（CFHk）模块

![](/assets/img/academic/RWGuard/Figure1.png)
DMon模块仅将IRP写请求视为输入，并监视是否存在对诱饵文件的写请求。PMon和FCMon模块分别监视进程操作（IRP open、close、read、write、create）和文件更改（IRP write）。这两个模块互相通信以识别对文件进行重大异常更改的任何进程。如果识别出此类事件，FCls模块将检查文件的属性，并预测文件更改事件是正常的可能性。此外，CFHk模块还检查在文件发生重大更改时是否为此文件记录了良性加密。

### 3.3 诱饵监视（DMon）模块

DMon模块部署诱饵文件，使我们的系统能够实时识别运行的勒索软件进程。由于在正常情况下不应修改诱饵文件，因此每当（勒索软件）进程试图写入此类文件时，此模块可以立即将该进程标识为恶意。此外，大量诱饵文件（尽管体积较小）的存在增加了勒索软件甚至在试图加密原始文件之前加密其中一个文件的可能性。因此，使用诱饵文件的优点有两个：  
（1）它允许检测系统容易地识别恶意进程  
（2）它延迟了勒索软件开始加密原始文件的时间，从而为异常检测提供了足够的时间来完成其分析，并在恶意进程开始加密原始文件之前停止它们（关于RWGuard完成分析所需时间的实验数据，见第5.2节）。  
RWGuard诱饵文件是用一个自动诱饵生成器工具生成的，我们将在第4.2节中详细讨论这个工具。注意，我们的诱饵生成器会定期修改诱饵文件，这样即使勒索软件查看最后一次修改文件的时间（以确保其加密的文件对用户有价值），它也无法识别诱饵文件。  


### 3.4 进程监控（PMon）模块

与某些现有方法在进程的I / O请求中使用特定模式（例如，读取→加密→删除）不同，我们利用勒索软件通常试图快速加密数据这一事实（ 以最大程度地破坏并最大程度地减少被发现的机会），从而导致IRP数量异常。  
利用此属性可以加快检测速度，因为IRP可以在实际的文件操作前进行记录。我们的PMon模块监控系统上运行的进程发出的I/O请求。尽管IRP是请求I/O操作的默认机制，但许多勒索软件使用快速I/O请求执行文件操作。快速I/O是专门为高速缓存文件上的快速同步I/O操作而设计的，它绕过了文件系统和存储驱动程序堆栈。
因此，在我们的设计中，我们同时监视IRP和快速I/O请求。快速I/O操作可以是表1中列出的任何类型。由于勒索软件进程对文件进行了快速加密，这些进程的行为具有一定的特征。因此，在这个模块中，我们训练一个机器学习模型，该模型给定进程的I/O请求，将进程标识为良性或勒索软件。缓慢加密文件的勒索软件可能会避开此模块，但可以由第3.5节所述由FCMon模块标识。

**进程分析** 为了训练机器学习模型，第一步，我们收集了良性和勒索软件过程的IRP（这里的IRP同时表示I/O和快速I/O）。表2显示了这个训练阶段使用的IRP特征，其中还包括创建的临时文件的数量。临时文件（.TMP）通常由勒索软件创建，用于在复制或删除原始文件时保存数据。一旦在训练阶段建立了良性和勒索软件过程的概要文件，PMon模块的进程概要文件组件（图1）将存储模型参数，以实时检查运行进程的参数（即测试阶段）。PMon模块通过3s滑动窗口为每个运行的进程计算表2中列出的特征。

![](/assets/img/academic/RWGuard/T1-2.png)

**训练阶段**：数据收集和分类器训练步骤如下：

**1.数据收集**：对于训练集，我们从勒索软件样本和良性应用程序中收集进程的IRP数据。我们使用九个最受欢迎的勒索软件家族，即：Wannacry, Cerber, CryptoLocker, Petya, Mamba, TeslaCrypt, CryptoWall, Locky, 和Jigsaw的IRP数据用于训练。良性进程包括如Explorer.exe、WmiPrvSE.exe、svchost.exe、FileSpy.exe、vmtoolsd.exe、csrss.exe、System、SearchFilter-Host.exe、SearchProtocolHost.exe、SearchIndexer.exe、chrome.exe、GoogleUp-date.exe、services.exe、audiodg.exe、WinRAR.exe、taskhost.exe、drpbx.exe、lsass.exe.值得注意的是，大多数勒索软件在执行过程中会产生多个恶意进程。我们最终的训练数据集包含261个进程(良性和恶意)的IRP。

**2.训练分类器:**利用训练数据，我们训练了一个机器学习分类器，该分类器在给定一组进程的情况下，能够区分勒索软件进程和良性进程。为了确定最佳的分类器，我们对不同的机器学习算法进行了分析即：朴素贝叶斯（使用估计类）、logistic回归（带岭估计的多项式logistic回归模型）、决策树和随机森林。我们对所获得的数据集进行了10折交叉验证，并对上述每个分类器的准确度、精确度、召回率、真阳性率和假阳性率进行了测量。  
表3给出了分析中使用的分类器的比较  
 图2显示了所有分类器的ROC曲线结果（绘制了真实阳性率与阴性阳性率）  
 朴素贝叶斯分类器的低准确性（〜80％）可以归因于其条件独立性。勒索软件通常采用读，写，打开和关闭请求的组合，因此假设这些参数彼此独立会导致较低的精度。 回归分类器比朴素的贝叶斯分类器稍好一些，准确度约为81％。逻辑回归模型在特征空间中搜索以个线性决策边界。因此，较低的准确度可归因于我们的数据没有决策的线性边界这一事实。原因：与打开/关闭请求相比，许多勒索软件发出了大量的写/读请求。 因此我们的数据集的理想决策边界将是非线性的。

![](/assets/img/academic/RWGuard/T3.png)
![](/assets/img/academic/RWGuard/Figure2.png)

**测试阶段**：在测试阶段，除了训练用的9个勒索软件家族，我们在实验集中添加了另外5个勒索软件家族：Vipasana,Satana,Ramamant,Rex和Matsnu。 这些样本一次执行一个，并根据生成的进程及其活动来标记恶意进程。 测试阶段结果的详细信息在第五节中给出

**文件加密**。在我们的实验中，我们发现很有少数良性进程（例如Chrome，VMware工具）由于I / O行为而被模型分类为恶意程序。 因此，除了监视进程分析指标外，监视特定进程是否负责任何重要的文件更改也很重要。 因此，我们的PMon模块将文件加密视为重要参数（如第3.5节中所述，与FCMon模块进行通信），并且仅在对文件进行加密以及带有异常I / O行为的迹象时，才将进程识别为恶意。


### 3.5 文件更改监视（FCMon）模块

此监视模块可以配置为针对从单个目录到整个文件系统的一系列文件。它计算并存储文件的初始属性（或在创建文件时动态计算属性），这些属性在文件更改时会相应地更新。在实时性方面，FCMon模块在每次写操作之后使用以下度量来查找这些文件中的显著更改：
（1）相似性（2）熵（3）文件类型更改（4）文件大小更改。

虽然这些度量中的一些已经在现有的工作中被用于勒索软件检测，我们的目标是验证PMon模块的快速检测，从而最小化假阳性率。在下面的内容中，我们描述了FCMon模块的文件管理器组件，并给出了上述度量的详细信息。

**文件管理器**。此组件存储每个文件的当前属性（例如，文件类型、文件的熵、文件大小、最近修改时间等），以便在写入操作时检测到文件属性的任何重大更改。如果创建了新文件，此组件将立即计算新文件的属性并将其存储在映射中（键：文件名和路径，值：计算属性）。

**指标**  FCMon模块的度量如下：

1. **相似性度量**：与良性文件更改（例如，修改一些现有文本或添加一些文本）相比，加密将导致与原始数据非常不同的数据。因此，文件先前（写操作之前）和之后（写操作之后）版本之间的相似性是理解文件更改特征的重要因素。为了计算两个版本之间的相似度，我们使用了由Roussev等人提出的一个保持相似度的hash函数**sdhash**用于生成文件哈希。sdhash函数输出0-100范围内的分数。当我们计算两个完全随机的数据数组之间的相似性时，得到0分。相反，当我们计算两个完全相同的文件之间的相似性时，会得到100分。因此在加密的情况下，此函数会输出接近0的值。

2. **熵度量**：熵，与数字信息有关，是对一组给定值（数据）中的随机性的度量，即在文件上计算时，它提供有关文件中数据随机性的信息。 因，可以肯定，用户的纯文本格式的数据文件具有较低的熵，而其加密版本将具有较高的熵。 与加密数据相比，压缩数据与其纯文本格式相比还具有较高的熵。 

   广泛使用的熵计算技术是香农熵。N字节数组（假设ASCII字符的值从0到255）的Shannon熵可以用如下公式计算：$\sum_{i=0}^{255}P_i\log_2 {1\over {P_i}}$。 $P_i$在这里是从数组中随机选择的字节是i的概率，例如$P_i = {F_i \over N}$，$F_i$是字节i在数组中出现的频率。这个方程的返回值在0-8范围内，价值数组中字节值是均匀分布的，则输出值为8。由于加密文件的字节分布更均匀（与明文版本相比），加密后的香农熵会显著增加，结果接近8

3. **文件类型更改度量**：文件在存在期间通常不会更改其类型。然而，勒索软件家族在加密后更改文件类型是很常见的。因此每当写入文件时，我们都会比较写入操作前后的文件类型。

4. **文件大小更改度量**：与文件类型更改不同，文件大小更改是一个常见事件，例如，向文档添加大文本。但是，此度量和其他度量一起采用时可以确定文件更改是良性的还是恶意的。

在检测到导致文件类型更改或文件更改超过指标的给定阈值：

**相似性得分<50**，**熵值> 6**，**显着改变了文件大小**

FCMon模块将与PMon，FCls和dCFHk模块共享记录的指标，以进行进一步评估。

### 3.6 文件分类（FCls）模块

在PMon和FCMon模块协同识别出对异常的I/O行为和文件更改负责的进程之后，我们的检测系统会对文件是被勒索软件加密的还是由于良性操作而导致的更改进行分类。我们的FCls模块通过学习crypto工具（一个利用CryptoAPI的实用程序，用于用户敏感文件的加密和解密，例如Krypte）的用法并分析用户的加密行为来执行此分类。例如，如果一个文件是从同一个目录中加密的，并且具有与以前有益的加密文件相同类型的文件，则此模块会认为此文件是良性加密的概率比较高（但是勒索软件不能滥用这一思想，见第3.7节CFHk模块）。如果一个文件属于良性加密的概率太低，并且已经被被加密，FCls模块会立即发出一个标志。为了消除假阴性的误报（即勒索软件对具有良性加密可能性的文件进行加密），将使用CFHk模块验证加密信息，该模块拦截良性加密。

**保护敏感文件**：如果在勒索软件攻击时敏感文件已经加密，勒索软件可以进一步加密这些文件，使这些文件不可用。请注意，FCMon模块可能无法以高概率标记此事件。原因是熵不会发生显著变化，因为两个文件版本（勒索软件加密之前和之后）的熵都很高。为了解决这个问题，我们修改加密文件的权限设置，即当用户使用加密工具加密文件时，我们仅允许对加密文件进行解密和删除（每个操作都需要用于加密的对称密钥），因为在解密前编辑/修改加密文件是不切实际的

### 3.7 CryptoAPI函数钩子（CFHk）模块

如第3.6节所述，如果FCls模块将更改归类为可能是良性加密的结果之后，我们需要进一步研究是否是使用加密工具执行的加密。 因此，CFHk模块将钩子放在CryptoAPI库函数的开头，以将执行控制重定向到我们自定义编写的函数。图3显示了在CryptoAPI库中勾住CryptEncrypt功能的示例。 每当进程调用CryptEncrypt函数对某些文件进行加密时，放在CryptEncrypt函数的钩子都会将控制转移到影子CryptEncrypt函数中。 该影子CryptEncrypt函数为该特定调用提取一个元组<key,algo,file,timestamp,process>，并出于安全目的以加密形式存储此信息，以便其他进程无法访问它。 用于此加密的密钥来自用户设置的秘密密码。 一旦存储了元组，影子CryptEncrypt函数就将控制权返回到原始过程，并且该进程继续执行，就好像它根本没有被中断一样。 该挂钩过程的实现细节在第4.3节中讨论。
![](/assets/img/academic/RWGuard/Figure3.png)
为了确定是否使用加密工具执行文件加密，我们只需搜索由CFHk模块捕获的“CryptEncrypt”元组。

- 如果找不到这样的元组，我们将终止修改文件的进程，以便不再进行加密。
- 如果找到这样的元组，则加密是良性的（不需要任何操作），或者勒索软件使用CryptoAPI加密。在第二种情况下，我们可以使用元组中的密钥和算法信息来恢复所有文件（详见第5.4节）。因为在我们的系统中，我们还存储文件信息（通过将ReadFile调用与CryptEncrypt相关联），所以我们不需要遍历所有密钥来进行单个文件解密，这是对现有工作的改进[16]。  
因此，钩住CryptoAPI库函数的好处有两个：（1）跟踪用户的所有良性加密；（2）在勒索软件使用系统提供的加密库的情况下，恢复加密文件(例如Windows CryptoAPI）。


## 4 RWGuard实现

### 4.1 IRP解析器

当IRPLogger记录I/O请求时，IRPParser组件解析日志条目，提取I/O请求，并输入给DMon、PMon和FCMon模块。

### 4.2 诱饵文件生成器

我们设计了一个自动诱饵文件生成器工具，它根据原始文件系统和用户偏好生成诱饵文件。默认情况下在每个目录中，它都会生成一个诱饵文件。
其名称类似于同一目录中的一个原始文件（根据用户偏好随机选择或由用户选择），这样诱饵文件的名称对勒索软件来说就不会是随机的。
为了确保用户能够很容易地识别诱饵文件，根据用户的偏好选择命名选项，这也使得诱饵文件对于勒索软件来说更加不可预测。用户可以为不同的目录设置不同数量的诱饵文件。这样，更敏感的文件可以用一组更大的诱饵文件来保护，而且，手动设置数字可以让用户在正常操作期间更容易识别诱饵文件。
生成的诱饵文件的类型扩展名为`.txt，.doc，.pdf，.ppt和.xls`，文件的内容是从相邻文件的内容生成的。尽管我们没有观察到任何勒索软件中有选择性行为（例如，在加密前检查文件名、文件内容等），但我们的诱饵设计对未来的高级勒索软件是有弹性的。
我们系统中的诱饵文件的大小是根据原始文件系统中文件的大小从一个范围（通常从1kb到几MBs）随机抽取的，而诱饵文件的总空间开销限制为原始文件系统大小的5%。



### 4.3 CryptoAPI函数钩子

在我们的CFHk模块中，我们利用第2节中介绍的Detours库。Detours库通过将特定数量的字节（通常是5个字节）从原始函数的内存地址的开头移动到新创建的钩子函数来钩住函数。在原始函数的空白处，添加了一条非条件JMP指令，该指令将把控件传输到钩子函数。然后hook函数执行必要的操作（例如，安全地存储传递给原始函数的键和其他参数）。最后在这些操作中，添加了另一条无条件JMP指令，以将控件传输回原始函数。编译后的DLL文件被放入注册表项中，这样调用CryptoAPI函数的任何进程都将被钩住，而CFHk模块将存储与加密相关的信息。表4列出了我们勾住的CryptoAPI函数。

![](/assets/img/academic/RWGuard/T4.png)

## 5 评价

### 5.1 实验数据集

虽然存在各种勒索软件变体，但我们从最受欢迎的勒索软件系列中构建了一个全面的数据集：Locky，Cerber，Wannacry，Jigsaw，Cryptolocker，Mamba，Teslacrypt，Cryptowall，Petya，Vipasana，Satana，Ratamant，Rex和Matsnu。 

勒索软件样本是从Virus-Total ，Open Malware ，VXVault ，Zelster和Malc0de中收集的。 

在这些样本中，前9个系列已用于PMon模块的训练阶段。 但是，我们在检测阶段一次只运行这14个勒索软件样本的一个，以评估RWGuard模块的检测有效性和性能开销。剩下5个样本用于评估Pmon模块在未知的勒索软件样本中的表现。

### 5.2 检测效率

我们通过顺序运行勒索软件样本来评估RWGuard的性能。 每次执行勒索软件样本时，我们都会测量标记该勒索软件所产生的每个恶意进程所需的时间。 一旦检测到勒索软件，我们将还原系统并执行下一个勒索软件示例。

**使用诱饵进行检测**：我们观察到采用诱饵部署进行勒索软件检测的速度非常快，可以确保几乎零数据丢失。 IRPParser组件可以在一秒内解析收集的IRP日志。因此通过诱饵部署，我们的系统可以在下一个诱饵文件写入之前，识别勒索软件。

图4显示了使用和未使用诱饵部署的情况下，勒索软件样本在被检测前进行的写入、读取、打开和关闭行为的IRP数量（以及所有勒索软件的平均值）的比较。每个勒索软件系列的IRP（对于每个IRP类型）的数量是通过运行样本至少5次来计算的。我们发现，在诱饵部署后对于每种IRP类型，至少有一个数量级的改进。因此，勒索软件进程一旦开始发出IRP请求就可以很快被识别。对于勒索软件Locky、Jigsaw、Teslacrypt、Cryptowall、Radamant和Rex，我们观察到它们发出的第一个IRP写请求是针对**诱饵文件**（参见图4a），因此立即被识别。

![](/assets/img/academic/RWGuard/Figure4.png)

Wannacry勒索软件在发送对诱饵文件的写入请求之前最多可以发出18个IRP写入请求（最高值）（对于单个文件写入，可以有多个IRP写入请求）。IRP写入请求在实际写入操作之前发送，因此在终止进程之前可被加密的文件的实际数量可以忽略不计（这也取决于文件大小）。



### 5.3 加密数据的大小

就文件数量而言，Locky、Jig saw、Teslacrypt、Cryptowall、Radamant和Rex的样本在使用诱饵的情况下无法加密任何文件，这些家族的恶意进程在其第一个IRP写入请求中就被识别。Cerber、Wannacry、Cryptolocker、Vipasana和Satana在检测到它们之前发出的IRP写请求的数量分别为2、18、12、6和3。

由于IRP写入请求比实际操作提前发送，并且对于单个文件写入可以有多个IRP写入请求（在部署诱饵的情况下），因此平均丢失的文件数小于1，只有Wannacry和Cryptolocker能够在杀死其恶意进程之前加密一个文件。

勒索软件家族在没有任何诱饵部署的情况下发出的IRP请求的平均数量为538（假设勒索软件能够避开诱饵部署，而大多数家族的情况并非如此），而受影响的文件的平均数量小于10。检测前受影响的文件数量不仅取决于发出的IRP请求的数量，还取决于勒索软件进程启动加密进程的时间（这很重要）、加密类型、文件大小，勒索软件试图加密的文件数量（这是因为勒索软件需要为每个文件生成一个新密钥）。

### 5.4 文件恢复

CFHk模块可以恢复以下勒索软件家族加密的文件：Locky、CryptoWall和CryptoLocker。这些样本使用的加密算法分别是带CTR模式的AES、CBC模式的AES和AES。当前版本中的CFHk模块无法恢复勒索软件的自定义加密库加密的文件。

### 5.5 性能开销

DMon，FCls和CFHk模块的开销可以忽略不计  。

DMon 总空间开销为原始文件的5%，每天检查一次诱饵文件并重新生成，开销极小。

FCls模块使用文件类型和位置信息立即对文件进行分类。 挂钩CryptoAPI函数以及计算和存储相应的元组的开销为几毫秒（≤10毫秒），可以忽略不计，因此不会中断用户的正常操作。

![](/assets/img/academic/RWGuard/T5.png)

有一个主Java模块，它执行IRPLogger，收集系统中生成的所有IRP，使用IRPParser解析IRP，并为DMon、PMon和n个dFCMon模块运行三个并行线程。FCMon模块由用于计算熵和相似性索引值的组件组成，它们使用最小的CPU周期，因为只有在对文件执行写操作时才会调用这些值。表5显示了这些组件和主Java模块的内存使用情况。这个主Java模块和IRPLogger的平均CPU使用率分别为0.85%和1.02%。

**不同工作负载的开销**。上面讨论的性能开销是在运行web浏览器进程和集成开发环境（IDE）进程以及常规操作系统进程时记录的。但是，为了测量工作负载繁重的操作系统的RWGuard检测性能和开销，我们添加了几个进程：两个浏览器（Chrome和Internet Explorer）、两个ide（Eclipse和PyChar）、Windows Media Player、Skype和其他常规操作系统进程。根据我们的实验，这一繁重的工作负载不会显著影响RWGuard识别勒索软件进程所需的时间，同时我们观察到IRPLogger和Java模块由于这一繁重的工作负载而产生更高的内存开销（分别为244456kb和45436kb）。不受繁重工作负载影响的检测时间可以归因于这样一个事实：RWGuard每2秒获取一个IRPLogger条目，这与记录的条目数量无关（对于繁重工作负载的情况，日志条目的数量要高得多）。由于解析IRP日志不是一个昂贵的操作，对于繁重的工作负载情况，检测时间没有明显的变化。此外，FCMon度量计算的内存开销保持类似。
 

### 5.6 和现有方法的对比

略过

## 6 局限性和一些讨论

不可避免性：我们强大的诱饵设计使勒索软件无法通过诱饵软件的任何属性识别诱饵文件。 勒索软件将需要安装一些间谍软件并监视系统中的文件活动，以确定哪些文件由最终用户和应用程序修改，哪些文件由我们的诱饵工具执行。 此外，混淆技术可用于使勒索软件难以分析应用程序，以确定哪个应用程序是诱饵生成器。 我们的集成监控模块PMon和FCMon对包括勒索软件的任何恶意活动在内的指标进行审查。 例如，FCMon模块仍会检测到缓慢加密文件的勒索软件。 监控模块DMon，PMon和FCMondo不允许检测到勒索软件活动（即，防止误报），而FCls和CFHk模块则将良性文件操作与恶意文件操作区分开（即，防止误报）。 因此，我们认为与现代勒索软件无关，RWGuard大大提高了勒索软件的规避标准。


文件恢复：注意，FHK模块监视利用“CryptoAPI”功能的所有文件加密。因此，如果利用CryptoAPI库的勒索软件（我们分析的14个勒索软件系列中的3个使用此库）在我们检测到之前成功加密一组文件。使用钩子机制，我们可以检索那些特定加密函数调用的参数（包括解密密钥），从而还原加密的文件。我们的实验（第5.4节）表明，CFHk模块能够恢复3个勒索软件家族加密的文件，成功率为100%。其余勒索软件不使用CryptoAPI，而是使用它们的自定义编写的密码库。此外，代码混淆是现代勒索软件家族使用的一种常见技术。混淆策略，如增量打包和解包，使得在勒索软件二进制文件中识别加密原语更加困难。虽然有一些技术（例如在进程内存中寻找加密操作，但是由于它们的巨大性能开销，我们还没有将它们合并到我们的系统中。



**局限性**： 虽然DMon模块可以快速识别恶意程序，但PMon和FCMon模块是基于异常的，因此很可能会遗漏某些恶意活动。 同样，这些模块基于IRP调用和文件活动的日志记录。 记录这些活动与解析异常之间存在间隔，为勒索软件提供了机会。



## 7 相关工作

略

## 8 结论和未来的工作

在本文中，我们介绍了RWGuard，它可以实时检测用户机器上的加密勒索软件，同时避免由于用户的正常文件操作而引起的误报。我们针对14种最流行的勒索软件家族评估了RWGuard。 我们的实验表明，RWGuard可以有效地对勒索软件进行早期检测，假阳性率可以忽略不计（约0.1％），假阴性率可以为零，而开销仅为1.9％。 此外，RWGuard还可以恢复由相应勒索软件使用CryptoAPI加密的所有文件。 作为未来工作的一部分，我们计划分析其他现有的加密库，并实时扫描进程的内存以进行类似的操作，以便我们可以恢复用于加密的密钥并还原文件。 此外，我们计划在终止进程之前对勒索软件进程的内存进行快照，并对这些进程进行分析以获取加密/解密密钥的痕迹。

